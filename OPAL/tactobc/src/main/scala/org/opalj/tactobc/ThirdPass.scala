package org.opalj.tactobc

import org.opalj.br.instructions.{GOTO, IF_ACMPEQ, IF_ICMPEQ, IF_ICMPGE, IF_ICMPGT, IF_ICMPLE, IF_ICMPLT, IF_ICMPNE, IF_ACMPNE, Instruction, JSR, LOOKUPSWITCH, TABLESWITCH}
import org.opalj.collection.immutable.{IntIntPair, IntTrieSet}
import org.opalj.tac.{DUVar, Stmt}
import org.opalj.value.ValueInformation

import scala.collection.immutable.ArraySeq
import scala.collection.mutable
import scala.collection.mutable.ArrayBuffer

/**
 * Handles the post-processing of the translation of three-address code (TAC) statements
 * into Java bytecode instructions.
 *
 * Key responsibilities:
 * - Update the target of jump instructions
 */
object ThirdPass {

  /**
   * Updates the targets of all jump instructions in the generated bytecode.
   * For each conditional and unconditional jump instruction (such as IF_ICMPEQ, GOTO, etc.),
   * this method adjusts the branch offset to point to the correct bytecode location.
   *
   * @param tacStmts TAC statements and their respective indexes.
   * @param generatedByteCodeWithPC generated bytecode instructions with their respective program counter (PC)
   * @param tacTargetToByteCodePcs mapping of TAC targets to their respective generated bytecode program counters (PCs).
   * @param switchCases switch case mappings for lookup and table switch instructions.
   * @return the final, updated bytecode instructions, with adjusted branch targets.
   */
  def updateTargetsOfJumpInstructions(tacStmts: Array[(Stmt[DUVar[ValueInformation]], Int)], generatedByteCodeWithPC: ArrayBuffer[(Int, Instruction)], tacTargetToByteCodePcs: ArrayBuffer[(Int, Int)], switchCases: ArrayBuffer[(Int, Int)]): ArrayBuffer[(Int, Instruction)] = {
    val result = ArrayBuffer[(Int, Instruction)]()
    // Index for TAC statements
    var tacTargetToByteCodePcsIndex = 0

    generatedByteCodeWithPC.zipWithIndex.foreach {
      case ((pc, instruction), _) =>
        // Match and update branch instructions
        val updatedInstruction = instruction match {
          case IF_ICMPEQ(-1) =>
            tacTargetToByteCodePcsIndex -= 1
            val instruction = IF_ICMPEQ(updateBranchTargets(tacTargetToByteCodePcs, tacTargetToByteCodePcsIndex, pc))
            tacTargetToByteCodePcsIndex += 1
            instruction
          case IF_ICMPNE(-1) =>
            tacTargetToByteCodePcsIndex -= 1
            val instruction = IF_ICMPNE(updateBranchTargets(tacTargetToByteCodePcs, tacTargetToByteCodePcsIndex, pc))
            tacTargetToByteCodePcsIndex += 1
            instruction
          case IF_ICMPLT(-1) =>
            tacTargetToByteCodePcsIndex -= 1
            val instruction = IF_ICMPLT(updateBranchTargets(tacTargetToByteCodePcs, tacTargetToByteCodePcsIndex, pc))
            tacTargetToByteCodePcsIndex += 1
            instruction
          case IF_ICMPLE(-1) =>
            tacTargetToByteCodePcsIndex -= 1
            val instruction = IF_ICMPLE(updateBranchTargets(tacTargetToByteCodePcs, tacTargetToByteCodePcsIndex, pc))
            tacTargetToByteCodePcsIndex += 1
            instruction
          case IF_ICMPGT(-1) =>
            tacTargetToByteCodePcsIndex -= 1
            val instruction = IF_ICMPGT(updateBranchTargets(tacTargetToByteCodePcs, tacTargetToByteCodePcsIndex, pc))
            tacTargetToByteCodePcsIndex += 1
            instruction
          case IF_ICMPGE(-1) =>
            tacTargetToByteCodePcsIndex -= 1
            val instruction = IF_ICMPGE(updateBranchTargets(tacTargetToByteCodePcs, tacTargetToByteCodePcsIndex, pc))
            tacTargetToByteCodePcsIndex += 1
            instruction
          case IF_ACMPEQ(-1) =>
            tacTargetToByteCodePcsIndex -= 1
            val instruction = IF_ACMPEQ(updateBranchTargets(tacTargetToByteCodePcs, tacTargetToByteCodePcsIndex, pc))
            tacTargetToByteCodePcsIndex += 1
            instruction
          case IF_ACMPNE(-1) =>
            tacTargetToByteCodePcsIndex -= 1
            val instruction = IF_ACMPNE(updateBranchTargets(tacTargetToByteCodePcs, tacTargetToByteCodePcsIndex, pc))
            tacTargetToByteCodePcsIndex += 1
            instruction
          case GOTO(-1) =>
            GOTO(updateBranchTargets(tacTargetToByteCodePcs, tacTargetToByteCodePcsIndex, pc))
          case JSR(-1) =>
            JSR(updateBranchTargets(tacTargetToByteCodePcs, tacTargetToByteCodePcsIndex, pc))
          case LOOKUPSWITCH(defaultOffset, matchOffsets) =>
            val updatedMatchOffsets = matchOffsets.map { case IntIntPair(caseValue, _) =>
              val tacTarget = findTacTarget(switchCases, caseValue)
              IntIntPair(caseValue, updateSwitchTargets(tacTargetToByteCodePcs, tacTarget, pc))
            }
            val updatedDefaultOffset = updateSwitchTargets(tacTargetToByteCodePcs, defaultOffset, pc)
            LOOKUPSWITCH(updatedDefaultOffset, updatedMatchOffsets)
          case TABLESWITCH(defaultOffset, low, high, jumpOffsets) =>
            val updatedJumpOffsets = jumpOffsets.zipWithIndex.map { case (_, index) =>
              val tacTarget = findTacTarget(switchCases, index)
              updateSwitchTargets(tacTargetToByteCodePcs, tacTarget, pc)
            }
            val updatedDefaultOffset = updateSwitchTargets(tacTargetToByteCodePcs, defaultOffset, pc)
            TABLESWITCH(updatedDefaultOffset, low, high, updatedJumpOffsets.to(ArraySeq))
          case _ =>
            instruction
        }
        result += ((pc, updatedInstruction))

        // Only increment tacIndex when the current instruction corresponds to a TAC statement
        if (tacTargetToByteCodePcsIndex < tacStmts.length && directAssociationExists(tacTargetToByteCodePcs, tacTargetToByteCodePcs(tacTargetToByteCodePcsIndex)._1, pc)) {
          tacTargetToByteCodePcsIndex += 1
        }
    }
    ExprProcessor.uVarToLVIndex = mutable.Map[IntTrieSet, Int]()
    ExprProcessor.nextLVIndex = 1
    result
  }

  /**
   * Finds the corresponding TAC target for a given switch case value.
   *
   * @param npairs A list of pairs where each pair contains a switch case value and the corresponding TAC target.
   * @param caseValue The value of the switch case being processed.
   * @return The TAC target associated with the given switch case value.
   */
  def findTacTarget(npairs: ArrayBuffer[(Int, Int)], caseValue: Int): Int = {
    val tacTarget = npairs.find(_._1 == caseValue).map(_._2).get
    tacTarget
  }

  /**
   * Updates the branch target for jump instructions such as IF_ICMPEQ, GOTO, JSR, etc.
   *
   * @param tacTargetToByteCodePcs A list mapping TAC targets to bytecode program counters.
   * @param tacTargetToByteCodePcsIndex The index of the current TAC target.
   * @param currentPC The current bytecode program counter (PC).
   * @return The updated branch target offset.
   */
  def updateBranchTargets(tacTargetToByteCodePcs: ArrayBuffer[(Int, Int)], tacTargetToByteCodePcsIndex: Int, currentPC: Int): Int = {
    val tacTarget = tacTargetToByteCodePcs(tacTargetToByteCodePcsIndex)._1
    val byteCodeTarget = tacTargetToByteCodePcs(tacTarget)._2 - currentPC
    byteCodeTarget
  }

  /**
   * Updates the switch case target offsets for LOOKUPSWITCH and TABLESWITCH instructions.
   *
   * @param tacTargetToByteCodePcs A list mapping TAC targets to generated bytecode program counters.
   * @param tacTarget The TAC target that corresponds to a switch case.
   * @param currentPC The current bytecode program counter (PC).
   * @return The updated switch case target PC.
   */
  def updateSwitchTargets(tacTargetToByteCodePcs: ArrayBuffer[(Int, Int)], tacTarget: Int, currentPC: Int): Int = {
    val byteCodeTarget = tacTargetToByteCodePcs(tacTarget)._2 - currentPC
    byteCodeTarget
  }

  /**
   * Checks if a direct association exists between a given TAC target and a bytecode program counter.
   * This is used to verify if a bytecode instruction corresponds to a specific TAC statement.
   *
   * @param tacTargetToByteCodePcs A list mapping TAC targets to bytecode program counters.
   * @param tacTarget The TAC target to check.
   * @param bytecodePC The bytecode program counter (PC) to check.
   * @return true if the association exists, false otherwise.
   */
  def directAssociationExists(tacTargetToByteCodePcs: ArrayBuffer[(Int, Int)], tacTarget: Int, bytecodePC: Int): Boolean = {
    tacTargetToByteCodePcs.exists { case (tacGoto, bcPC) => (tacGoto, bcPC) == (tacTarget, bytecodePC) }
  }

}
